import { jsPDF } from 'jspdf'
import { format } from 'date-fns'

export async function generatePDF(content: string, title?: string): Promise<Blob> {
  const pdf = new jsPDF()
  
  // Set up document metadata
  if (title) {
    pdf.setProperties({
      title: title,
      author: 'NSAI Data Platform',
      subject: 'AI Research Report',
      keywords: 'AI, research, NSAI'
    })
  }

  // Add header
  pdf.setFontSize(20)
  pdf.text(title || 'Research Report', 20, 20)
  
  // Add timestamp
  pdf.setFontSize(10)
  pdf.text(`Generated: ${format(new Date(), 'PPP p')}`, 20, 30)
  
  // Add content with word wrapping
  pdf.setFontSize(12)
  const lines = pdf.splitTextToSize(content, 170) // 170mm width for A4
  pdf.text(lines, 20, 45)
  
  // Add footer with page numbers
  const pageCount = pdf.getNumberOfPages()
  for (let i = 1; i <= pageCount; i++) {
    pdf.setPage(i)
    pdf.setFontSize(8)
    pdf.text(`Page ${i} of ${pageCount}`, 200, 290, { align: 'right' })
    pdf.text('NSAI Data Platform', 20, 290)
  }
  
  return pdf.output('blob')
}

export function generateMarkdown(content: string, title?: string): Blob {
  let markdown = ''
  
  if (title) {
    markdown += `# ${title}\n\n`
  }
  
  markdown += `*Generated: ${format(new Date(), 'PPP p')}*\n\n`
  markdown += '---\n\n'
  markdown += content
  markdown += '\n\n---\n'
  markdown += '*Generated by NSAI Data Platform*'
  
  return new Blob([markdown], { type: 'text/markdown' })
}

export function generateJSON(data: any, includeMetadata: boolean = true): Blob {
  const output = includeMetadata ? {
    metadata: {
      exportedAt: new Date().toISOString(),
      platform: 'NSAI Data Platform',
      version: '1.0.0'
    },
    data
  } : data
  
  return new Blob([JSON.stringify(output, null, 2)], { type: 'application/json' })
}

export function generateCSV(data: any[], headers?: string[]): Blob {
  if (!data.length) {
    return new Blob(['No data available'], { type: 'text/csv' })
  }
  
  // Auto-generate headers if not provided
  const csvHeaders = headers || Object.keys(data[0])
  
  // Create CSV content
  const csvContent = [
    csvHeaders.join(','), // Header row
    ...data.map(row => 
      csvHeaders.map(header => {
        const value = row[header]
        // Escape values that contain commas or quotes
        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
          return `"${value.replace(/"/g, '""')}"`
        }
        return value ?? ''
      }).join(',')
    )
  ].join('\n')
  
  return new Blob([csvContent], { type: 'text/csv' })
}

export async function generateResearchReport(query: string, result: any, format: 'pdf' | 'markdown' | 'json' = 'pdf'): Promise<Blob> {
  const title = `Research Report: ${query.substring(0, 50)}...`
  
  if (format === 'json') {
    return generateJSON({
      query,
      result,
      exportType: 'research_report'
    })
  }
  
  // Format content for PDF/Markdown
  let content = `## Query\n${query}\n\n`
  
  if (typeof result === 'string') {
    content += `## Results\n${result}`
  } else if (result && typeof result === 'object') {
    if (result.summary) {
      content += `## Summary\n${result.summary}\n\n`
    }
    if (result.keyFindings) {
      content += `## Key Findings\n${Array.isArray(result.keyFindings) ? result.keyFindings.join('\n- ') : result.keyFindings}\n\n`
    }
    if (result.analysis) {
      content += `## Analysis\n${result.analysis}\n\n`
    }
    if (result.recommendations) {
      content += `## Recommendations\n${result.recommendations}\n\n`
    }
    if (result.sources) {
      content += `## Sources\n${Array.isArray(result.sources) ? result.sources.join('\n- ') : result.sources}`
    }
  }
  
  return format === 'pdf' 
    ? generatePDF(content, title)
    : generateMarkdown(content, title)
}

export function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = filename
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}